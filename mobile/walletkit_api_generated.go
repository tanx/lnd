// Code generated by falafel 0.3. DO NOT EDIT.
// source: walletrpc/walletkit.proto

// +build walletrpc

package lndmobile

import (
	"context"
	"net"
	"time"

	"google.golang.org/grpc"

	"github.com/golang/protobuf/proto"

	"github.com/lightningnetwork/lnd/lnrpc/walletrpc"
)

func getWalletKitConn() (*grpc.ClientConn, func(), error) {
	conn, err := lightningLis.Dial()
	if err != nil {
		return nil, nil, err
	}

	clientConn, err := grpc.Dial("",
		grpc.WithDialer(func(target string,
			timeout time.Duration) (net.Conn, error) {
			return conn, nil
		}),
		grpc.WithInsecure(),
		grpc.WithBackoffMaxDelay(10*time.Second),
	)
	if err != nil {
		conn.Close()
		return nil, nil, err
	}

	close := func() {
		conn.Close()
	}

	return clientConn, close, nil
}

// getWalletKitClient returns a client connection to the server listening
// on lis.
func getWalletKitClient() (walletrpc.WalletKitClient, func(), error) {
	clientConn, close, err := getWalletKitConn()
	if err != nil {
		return nil, nil, err
	}
	client := walletrpc.NewWalletKitClient(clientConn)
	return client, close, nil
}

// DeriveNextKey attempts to derive the *next* key within the key family
// (account in BIP43) specified. This method should return the next external
// child within this branch.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func DeriveNextKey(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.KeyReq{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*walletrpc.KeyReq)
			return client.DeriveNextKey(ctx, r)
		},
	}
	s.start(msg, callback)
}

// DeriveKey attempts to derive an arbitrary key specified by the passed
// KeyLocator.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func DeriveKey(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &signrpc.KeyLocator{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*signrpc.KeyLocator)
			return client.DeriveKey(ctx, r)
		},
	}
	s.start(msg, callback)
}

// NextAddr returns the next unused address within the wallet.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func NextAddr(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.AddrRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*walletrpc.AddrRequest)
			return client.NextAddr(ctx, r)
		},
	}
	s.start(msg, callback)
}

// PublishTransaction attempts to publish the passed transaction to the
// network. Once this returns without an error, the wallet will continually
// attempt to re-broadcast the transaction on start up, until it enters the
// chain.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func PublishTransaction(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.Transaction{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*walletrpc.Transaction)
			return client.PublishTransaction(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SendOutputs is similar to the existing sendmany call in Bitcoind, and
// allows the caller to create a transaction that sends to several outputs at
// once. This is ideal when wanting to batch create a set of transactions.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func SendOutputs(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.SendOutputsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*walletrpc.SendOutputsRequest)
			return client.SendOutputs(ctx, r)
		},
	}
	s.start(msg, callback)
}

// EstimateFee attempts to query the internal fee estimator of the wallet to
// determine the fee (in sat/kw) to attach to a transaction in order to
// achieve the confirmation target.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func EstimateFee(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.EstimateFeeRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*walletrpc.EstimateFeeRequest)
			return client.EstimateFee(ctx, r)
		},
	}
	s.start(msg, callback)
}

// PendingSweeps returns lists of on-chain outputs that lnd is currently
// attempting to sweep within its central batching engine. Outputs with similar
// fee rates are batched together in order to sweep them within a single
// transaction.
//
// NOTE: Some of the fields within PendingSweepsRequest are not guaranteed to
// remain supported. This is an advanced API that depends on the internals of
// the UtxoSweeper, so things may change.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func PendingSweeps(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.PendingSweepsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*walletrpc.PendingSweepsRequest)
			return client.PendingSweeps(ctx, r)
		},
	}
	s.start(msg, callback)
}

// BumpFee bumps the fee of an arbitrary input within a transaction. This RPC
// takes a different approach than bitcoind's bumpfee command. lnd has a
// central batching engine in which inputs with similar fee rates are batched
// together to save on transaction fees. Due to this, we cannot rely on
// bumping the fee on a specific transaction, since transactions can change at
// any point with the addition of new inputs. The list of inputs that
// currently exist within lnd's central batching engine can be retrieved
// through the PendingSweeps RPC.
//
// When bumping the fee of an input that currently exists within lnd's central
// batching engine, a higher fee transaction will be created that replaces the
// lower fee transaction through the Replace-By-Fee (RBF) policy. If it
//
// This RPC also serves useful when wanting to perform a Child-Pays-For-Parent
// (CPFP), where the child transaction pays for its parent's fee. This can be
// done by specifying an outpoint within the low fee transaction that is under
// the control of the wallet.
//
// The fee preference can be expressed either as a specific fee rate or a delta
// of blocks in which the output should be swept on-chain within. If a fee
// preference is not explicitly specified, then an error is returned.
//
// Note that this RPC currently doesn't perform any validation checks on the
// fee preference being provided. For now, the responsibility of ensuring that
// the new fee preference is sufficient is delegated to the user.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func BumpFee(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.BumpFeeRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*walletrpc.BumpFeeRequest)
			return client.BumpFee(ctx, r)
		},
	}
	s.start(msg, callback)
}
