// +build walletrpc

// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: walletrpc/walletkit.proto
package lndmobile

import (
	"context"
	"net"
	"time"

	"google.golang.org/grpc"

	"github.com/golang/protobuf/proto"

	"github.com/lightningnetwork/lnd/lnrpc/walletrpc"
)

func getWalletKitConn() (*grpc.ClientConn, func(), error) {
	conn, err := lightningLis.Dial()
	if err != nil {
		return nil, nil, err
	}

	clientConn, err := grpc.Dial("",
		grpc.WithDialer(func(target string,
			timeout time.Duration) (net.Conn, error) {
			return conn, nil
		}),
		grpc.WithInsecure(),
		grpc.WithBackoffMaxDelay(10*time.Second),
	)
	if err != nil {
		conn.Close()
		return nil, nil, err
	}

	close := func() {
		conn.Close()
	}

	return clientConn, close, nil
}

// getWalletKitClient returns a client connection to the server listening
// on lis.
func getWalletKitClient() (walletrpc.WalletKitClient, func(), error) {
	clientConn, close, err := getWalletKitConn()
	if err != nil {
		return nil, nil, err
	}
	client := walletrpc.NewWalletKitClient(clientConn)
	return client, close, nil
}

// DeriveNextKey attempts to derive the *next* key within the key family
// (account in BIP43) specified. This method should return the next external
// child within this branch.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func DeriveNextKey(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.KeyReq{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*walletrpc.KeyReq)
			return client.DeriveNextKey(ctx, r)
		},
	}
	s.start(msg, callback)
}

// DeriveKey attempts to derive an arbitrary key specified by the passed
// KeyLocator. 
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func DeriveKey(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &signrpc.KeyLocator{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*signrpc.KeyLocator)
			return client.DeriveKey(ctx, r)
		},
	}
	s.start(msg, callback)
}

// NextAddr returns the next unused address within the wallet.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func NextAddr(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.AddrRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*walletrpc.AddrRequest)
			return client.NextAddr(ctx, r)
		},
	}
	s.start(msg, callback)
}

// PublishTransaction attempts to publish the passed transaction to the
// network. Once this returns without an error, the wallet will continually
// attempt to re-broadcast the transaction on start up, until it enters the
// chain.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func PublishTransaction(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.Transaction{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*walletrpc.Transaction)
			return client.PublishTransaction(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SendOutputs is similar to the existing sendmany call in Bitcoind, and
// allows the caller to create a transaction that sends to several outputs at
// once. This is ideal when wanting to batch create a set of transactions.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func SendOutputs(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.SendOutputsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*walletrpc.SendOutputsRequest)
			return client.SendOutputs(ctx, r)
		},
	}
	s.start(msg, callback)
}

// EstimateFee attempts to query the internal fee estimator of the wallet to
// determine the fee (in sat/kw) to attach to a transaction in order to
// achieve the confirmation target.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func EstimateFee(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.EstimateFeeRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*walletrpc.EstimateFeeRequest)
			return client.EstimateFee(ctx, r)
		},
	}
	s.start(msg, callback)
}

// PendingSweeps returns lists of on-chain outputs that lnd is currently
// attempting to sweep within its central batching engine. Outputs with similar
// fee rates are batched together in order to sweep them within a single
// transaction.
// 
// NOTE: Some of the fields within PendingSweepsRequest are not guaranteed to
// remain supported. This is an advanced API that depends on the internals of
// the UtxoSweeper, so things may change.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitPendingSweeps(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.PendingSweepsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*walletrpc.PendingSweepsRequest)
			return client.PendingSweeps(ctx, r)
		},
	}
	s.start(msg, callback)
}


//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitBumpFee(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.BumpFeeRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*walletrpc.BumpFeeRequest)
			return client.BumpFee(ctx, r)
		},
	}
	s.start(msg, callback)
}
