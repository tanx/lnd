// +build autopilotrpc

// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: autopilotrpc/autopilot.proto
package lndmobile

import (
	"context"
	"net"
	"time"

	"google.golang.org/grpc"

	"github.com/golang/protobuf/proto"

	"github.com/lightningnetwork/lnd/lnrpc/autopilotrpc"
)

func getAutopilotConn() (*grpc.ClientConn, func(), error) {
	conn, err := lightningLis.Dial()
	if err != nil {
		return nil, nil, err
	}

	clientConn, err := grpc.Dial("",
		grpc.WithDialer(func(target string,
			timeout time.Duration) (net.Conn, error) {
			return conn, nil
		}),
		grpc.WithInsecure(),
		grpc.WithBackoffMaxDelay(10*time.Second),
	)
	if err != nil {
		conn.Close()
		return nil, nil, err
	}

	close := func() {
		conn.Close()
	}

	return clientConn, close, nil
}

// getAutopilotClient returns a client connection to the server listening
// on lis.
func getAutopilotClient() (autopilotrpc.AutopilotClient, func(), error) {
	clientConn, close, err := getAutopilotConn()
	if err != nil {
		return nil, nil, err
	}
	client := autopilotrpc.NewAutopilotClient(clientConn)
	return client, close, nil
}

// Status returns whether the daemon's autopilot agent is active.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func AutopilotStatus(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &autopilotrpc.StatusRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getAutopilotClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*autopilotrpc.StatusRequest)
			return client.Status(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ModifyStatus is used to modify the status of the autopilot agent, like
// enabling or disabling it.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func AutopilotModifyStatus(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &autopilotrpc.ModifyStatusRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getAutopilotClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*autopilotrpc.ModifyStatusRequest)
			return client.ModifyStatus(ctx, r)
		},
	}
	s.start(msg, callback)
}

// QueryScores queries all available autopilot heuristics, in addition to any
// active combination of these heruristics, for the scores they would give to
// the given nodes.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func AutopilotQueryScores(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &autopilotrpc.QueryScoresRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getAutopilotClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*autopilotrpc.QueryScoresRequest)
			return client.QueryScores(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SetScores attempts to set the scores used by the running autopilot agent,
// if the external scoring heuristic is enabled.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func AutopilotSetScores(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &autopilotrpc.SetScoresRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getAutopilotClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*autopilotrpc.SetScoresRequest)
			return client.SetScores(ctx, r)
		},
	}
	s.start(msg, callback)
}
