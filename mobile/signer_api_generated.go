// Code generated by falafel 0.3. DO NOT EDIT.
// source: signrpc/signer.proto

// +build signrpc

package lndmobile

import (
	"context"
	"net"
	"time"

	"google.golang.org/grpc"

	"github.com/golang/protobuf/proto"

	"github.com/lightningnetwork/lnd/lnrpc/signrpc"
)

func getSignerConn() (*grpc.ClientConn, func(), error) {
	conn, err := lightningLis.Dial()
	if err != nil {
		return nil, nil, err
	}

	clientConn, err := grpc.Dial("",
		grpc.WithDialer(func(target string,
			timeout time.Duration) (net.Conn, error) {
			return conn, nil
		}),
		grpc.WithInsecure(),
		grpc.WithBackoffMaxDelay(10*time.Second),
	)
	if err != nil {
		conn.Close()
		return nil, nil, err
	}

	close := func() {
		conn.Close()
	}

	return clientConn, close, nil
}

// getSignerClient returns a client connection to the server listening
// on lis.
func getSignerClient() (signrpc.SignerClient, func(), error) {
	clientConn, close, err := getSignerConn()
	if err != nil {
		return nil, nil, err
	}
	client := signrpc.NewSignerClient(clientConn)
	return client, close, nil
}

// SignOutputRaw is a method that can be used to generated a signature for a
// set of inputs/outputs to a transaction. Each request specifies details
// concerning how the outputs should be signed, which keys they should be
// signed with, and also any optional tweaks. The return value is a fixed
// 64-byte signature (the same format as we use on the wire in Lightning).
//
// If we are  unable to sign using the specified keys, then an error will be
// returned.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func SignOutputRaw(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &signrpc.SignReq{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getSignerClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*signrpc.SignReq)
			return client.SignOutputRaw(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ComputeInputScript generates a complete InputIndex for the passed
// transaction with the signature as defined within the passed SignDescriptor.
// This method should be capable of generating the proper input script for
// both regular p2wkh output and p2wkh outputs nested within a regular p2sh
// output.
//
// Note that when using this method to sign inputs belonging to the wallet,
// the only items of the SignDescriptor that need to be populated are pkScript
// in the TxOut field, the value in that same field, and finally the input
// index.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ComputeInputScript(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &signrpc.SignReq{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, close, err := getSignerClient()
			if err != nil {
				return nil, err
			}
			defer close()

			r := req.(*signrpc.SignReq)
			return client.ComputeInputScript(ctx, r)
		},
	}
	s.start(msg, callback)
}
